
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000039c  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000004  0000039c  0000039c  0000839c  2**2
                  ALLOC
  2 .stack        00001000  00000400  00000400  0000839c  2**0
                  ALLOC
  3 .comment      0000001b  00000000  00000000  0000839c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000040  00000000  00000000  000083b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000000ad  00000000  00000000  000083f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000025e  00000000  00000000  000084a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000125  00000000  00000000  00008703  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000138  00000000  00000000  00008828  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000b8  00000000  00000000  00008960  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000113  00000000  00000000  00008a18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000bb  00000000  00000000  00008b2b  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------------------------------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
   4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
   8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
   c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
  10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
  14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xffffdc30>
        ldr   pc,_fiq                   // FIQ - _fiq
  1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
  20:	00000038 	andeq	r0, r0, r8, lsr r0

00000024 <_swi>:
  24:	0000003c 	andeq	r0, r0, ip, lsr r0

00000028 <_pabt>:
  28:	00000040 	andeq	r0, r0, r0, asr #32

0000002c <_dabt>:
  2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <_irq>:
  30:	00000048 	andeq	r0, r0, r8, asr #32

00000034 <_fiq>:
  34:	0000004c 	andeq	r0, r0, ip, asr #32

00000038 <__undf>:


// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <FIQ_BIT>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
  4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:

        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// -------------------------------------------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Who am I? Where am I going?

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// ----------------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
  50:	e59f00c8 	ldr	r0, [pc, #200]	; 120 <.text+0x120>
		mrs   r1,CPSR
  54:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  58:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
  5c:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
  60:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  64:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
  68:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  6c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  70:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
  74:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
  78:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  7c:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
  80:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  84:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  88:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
  8c:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
  90:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  94:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
  98:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  9c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  a0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
  a4:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
  a8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  ac:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
  b0:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  b4:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  b8:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
  bc:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
  c0:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  c4:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
  c8:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  cc:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  d0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
  d4:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
  d8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  dc:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -------------------------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
        ldr   r2,=_data                 // -> data start
        ldr   r3,=_edata                // -> end of data
x01:    cmp   r2,r3                     // check if data to move
		beq   y01
        ldrlo r0,[r1],#4                // copy it
        strlo r0,[r2],#4
        blo   x01                       // loop until done
y01:
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
  e0:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
  e4:	e59f1038 	ldr	r1, [pc, #56]	; 124 <.text+0x124>
        ldr   r2,=__bss_end__           // -> bss end
  e8:	e59f2038 	ldr	r2, [pc, #56]	; 128 <.text+0x128>

000000ec <x02>:
x02:    cmp   r1,r2                     // check if data to clear
  ec:	e1510002 	cmp	r1, r2
		beq   y02
  f0:	0a000001 	beq	fc <y02>
        strlo r0,[r1],#4                // clear 4 bytes
  f4:	34810004 	strcc	r0, [r1], #4
        blo   x02                       // loop until done
  f8:	3afffffb 	bcc	ec <x02>

000000fc <y02>:
y02:
// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  fc:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
 100:	e1a01000 	mov	r1, r0
        mov   r2,r0
 104:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
 108:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
 10c:	e1a07000 	mov	r7, r0
        ldr   r10,=main
 110:	e59fa014 	ldr	sl, [pc, #20]	; 12c <.text+0x12c>
        mov   lr,pc
 114:	e1a0e00f 	mov	lr, pc
        mov   pc, r10                   // enter main()
 118:	e1a0f00a 	mov	pc, sl

0000011c <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
 11c:	eafffffe 	b	11c <_reset>
 120:	00001400 	andeq	r1, r0, r0, lsl #8
 124:	0000039c 	muleq	r0, ip, r3
 128:	000003a0 	andeq	r0, r0, r0, lsr #7
 12c:	00000294 	muleq	r0, r4, r2

00000130 <timer0_isr>:
/* ---- IRQ: Timer ISR ---- */
volatile unsigned long timeval;
void __attribute__ ((interrupt("IRQ"))) timer0_isr(void);
void timer0_isr(void)
{
 130:	e92d000e 	stmdb	sp!, {r1, r2, r3}
  timeval++;
 134:	e59f2028 	ldr	r2, [pc, #40]	; 164 <.text+0x164>
 138:	e5923000 	ldr	r3, [r2]
 13c:	e2833001 	add	r3, r3, #1	; 0x1
 140:	e5823000 	str	r3, [r2]
  SSEG0_DATA = timeval;
 144:	e5921000 	ldr	r1, [r2]
 148:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 14c:	e5031ff7 	str	r1, [r3, #-4087]
  VICVectAddr = 0;
 150:	e3a02000 	mov	r2, #0	; 0x0
 154:	e2833a0f 	add	r3, r3, #61440	; 0xf000
 158:	e5032fcf 	str	r2, [r3, #-4047]
}
 15c:	e8bd000e 	ldmia	sp!, {r1, r2, r3}
 160:	e25ef004 	subs	pc, lr, #4	; 0x4
 164:	0000039c 	muleq	r0, ip, r3

00000168 <spi0_send_byte>:


/* ---- SPI 0 Transmission ---- */
void spi0_send_byte(int data, int slave_id)
{
 168:	e3e0ca0f 	mvn	ip, #61440	; 0xf000
  while((SPI0_CONF & (1<<8)) != 0); // spi busy?
 16c:	e51c3fcf 	ldr	r3, [ip, #-4047]
 170:	e3130c01 	tst	r3, #256	; 0x100
 174:	1afffffc 	bne	16c <spi0_send_byte+0x4>
  SPI0_DAT0 = data;
  SPI0_SCSR = ~slave_id & 255;
 178:	e1e02001 	mvn	r2, r1
 17c:	e20220ff 	and	r2, r2, #255	; 0xff
 180:	e50c0fbf 	str	r0, [ip, #-4031]
 184:	e50c2fc7 	str	r2, [ip, #-4039]
  SPI0_CONF = SPI0_CONF | 256;
 188:	e51c3fcf 	ldr	r3, [ip, #-4047]
 18c:	e3833c01 	orr	r3, r3, #256	; 0x100
 190:	e50c3fcf 	str	r3, [ip, #-4047]
}
 194:	e1a0f00e 	mov	pc, lr

00000198 <uart0_read_byte>:


/* ---- UART0 read byte ---- */
int uart0_read_byte(void)
{
  if ((UART0_SREG & (1<<1)) != 0) // byte available?
 198:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 19c:	e5123fe3 	ldr	r3, [r2, #-4067]
 1a0:	e3130002 	tst	r3, #2	; 0x2
 1a4:	e3e00000 	mvn	r0, #0	; 0x0
    return UART0_DATA;
 1a8:	15120fe7 	ldrne	r0, [r2, #-4071]
  else
    return -1;
}
 1ac:	e1a0f00e 	mov	pc, lr

000001b0 <uart0_send_byte>:


/* ---- UART0 write byte ---- */
int uart0_send_byte(char ch)
{
 1b0:	e20000ff 	and	r0, r0, #255	; 0xff
 1b4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
  while((UART0_SREG & (1<<0)) == 0); // uart busy?
 1b8:	e5123fe3 	ldr	r3, [r2, #-4067]
 1bc:	e3130001 	tst	r3, #1	; 0x1
 1c0:	0afffffc 	beq	1b8 <uart0_send_byte+0x8>
  ch = ch & 255;
  UART0_DATA = ch;
 1c4:	e5020fe7 	str	r0, [r2, #-4071]
  return (int)ch;
}
 1c8:	e1a0f00e 	mov	pc, lr

000001cc <i2c0_send_byte>:


/* ---- I2C0 write byte ---- */
int i2c0_send_byte(char adr, int data)
{
  I2C0_CMD  = (1<<7) | (1<<4); // start condition
 1cc:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 1d0:	e3a02090 	mov	r2, #144	; 0x90
 1d4:	e5032faf 	str	r2, [r3, #-4015]
 1d8:	e20000ff 	and	r0, r0, #255	; 0xff
 1dc:	e1a02003 	mov	r2, r3
  while((I2C0_STAT & (1<<1)) != 0);  // wait for execution
 1e0:	e5123faf 	ldr	r3, [r2, #-4015]
 1e4:	e3130002 	tst	r3, #2	; 0x2
 1e8:	1afffffc 	bne	1e0 <i2c0_send_byte+0x14>

  I2C0_DATA = adr;
  I2C0_CMD  = (1<<4); // write to slave
 1ec:	e3a03010 	mov	r3, #16	; 0x10
 1f0:	e5020f93 	str	r0, [r2, #-3987]
 1f4:	e5023faf 	str	r3, [r2, #-4015]
 1f8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
  while((I2C0_STAT & (1<<7)) != 0); // wait for ack
 1fc:	e5123faf 	ldr	r3, [r2, #-4015]
 200:	e3130080 	tst	r3, #128	; 0x80
 204:	1afffffc 	bne	1fc <i2c0_send_byte+0x30>

  I2C0_DATA = data;
  I2C0_CMD  = (1<<4); // write to slave
 208:	e3a03010 	mov	r3, #16	; 0x10
 20c:	e5021f93 	str	r1, [r2, #-3987]
 210:	e5023faf 	str	r3, [r2, #-4015]
 214:	e3e02a0f 	mvn	r2, #61440	; 0xf000
  while((I2C0_STAT & (1<<7)) != 0); // wait for ack
 218:	e5123faf 	ldr	r3, [r2, #-4015]
 21c:	e3130080 	tst	r3, #128	; 0x80
 220:	1afffffc 	bne	218 <i2c0_send_byte+0x4c>

  I2C0_CMD  = (1<<6); // stop condition
 224:	e3a03040 	mov	r3, #64	; 0x40
 228:	e5023faf 	str	r3, [r2, #-4015]
 22c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
  while((I2C0_STAT & (1<<1)) != 0);  // wait for execution
 230:	e5123faf 	ldr	r3, [r2, #-4015]
 234:	e3130002 	tst	r3, #2	; 0x2
 238:	1afffffc 	bne	230 <i2c0_send_byte+0x64>
  return data;
}
 23c:	e1a00001 	mov	r0, r1
 240:	e1a0f00e 	mov	pc, lr

00000244 <enable_irq>:


/* ---- Enable IRQ ---- */
void enable_irq(void)
{
  unsigned long _cpsr;
  asm volatile (" mrs  %0, cpsr" : "=r" (_cpsr) : /* no inputs */  );
 244:	e10f3000 	mrs	r3, CPSR
  _cpsr = _cpsr & ~(1<<7);
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (_cpsr)  );
 248:	e3c33080 	bic	r3, r3, #128	; 0x80
 24c:	e129f003 	msr	CPSR_fc, r3
}
 250:	e1a0f00e 	mov	pc, lr

00000254 <disable_irq>:


/* ---- Disable IRQ ---- */
void disable_irq(void)
{
  unsigned long _cpsr;
  asm volatile (" mrs  %0, cpsr" : "=r" (_cpsr) : /* no inputs */  );
 254:	e10f3000 	mrs	r3, CPSR
  _cpsr = _cpsr | (1<<7);
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (_cpsr)  );
 258:	e3833080 	orr	r3, r3, #128	; 0x80
 25c:	e129f003 	msr	CPSR_fc, r3
}
 260:	e1a0f00e 	mov	pc, lr

00000264 <delay>:


/* ---- Delay function ---- */
void delay(int delay)
{
  int i;
  for(i=0; i<delay*10000; i++)
 264:	e0603280 	rsb	r3, r0, r0, lsl #5
 268:	e0800103 	add	r0, r0, r3, lsl #2
 26c:	e0800100 	add	r0, r0, r0, lsl #2
 270:	e1a00200 	mov	r0, r0, lsl #4
 274:	e3500000 	cmp	r0, #0	; 0x0
 278:	d1a0f00e 	movle	pc, lr
 27c:	e3a03000 	mov	r3, #0	; 0x0
    asm volatile ("NOP");
 280:	e1a00000 	nop			(mov r0,r0)
 284:	e2833001 	add	r3, r3, #1	; 0x1
 288:	e1530000 	cmp	r3, r0
 28c:	1afffffb 	bne	280 <delay+0x1c>
 290:	e1a0f00e 	mov	pc, lr

00000294 <main>:
}


/* ---- Main function ---- */
int main(void)
{
  int led_timer;
  int data;

  // display clear
  SSEG1_DATA = 0;
  SSEG0_DATA = 0;

  // SPI 0 init
  led_timer  = 0;
  SPI0_CONF  = (1<<10) | (1<<9) | 8;
 294:	e3a02c06 	mov	r2, #1536	; 0x600
 298:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
 29c:	e2822008 	add	r2, r2, #8	; 0x8
 2a0:	e3e04a0f 	mvn	r4, #61440	; 0xf000
 2a4:	e3a05000 	mov	r5, #0	; 0x0
  SPI0_PRSC  = 500; // 100kHz
 2a8:	e3a03f7d 	mov	r3, #500	; 0x1f4
 2ac:	e5045fef 	str	r5, [r4, #-4079]
  spi0_send_byte(0, 255);
 2b0:	e3a010ff 	mov	r1, #255	; 0xff
 2b4:	e5045ff7 	str	r5, [r4, #-4087]
 2b8:	e1a00005 	mov	r0, r5
 2bc:	e5042fcf 	str	r2, [r4, #-4047]
 2c0:	e5043fcb 	str	r3, [r4, #-4043]
 2c4:	ebffffa7 	bl	168 <spi0_send_byte>
  spi0_send_byte(0, 255);
 2c8:	e1a00005 	mov	r0, r5
 2cc:	e3a010ff 	mov	r1, #255	; 0xff
 2d0:	ebffffa4 	bl	168 <spi0_send_byte>

  // I²C 0 init
  I2C0_PRLO  = 99; // for 100kHz
 2d4:	e3a03063 	mov	r3, #99	; 0x63
  I2C0_PRHI  = 0;
  I2C0_CTRL  = (1<<7); // i2c enable

  // timer init
  timeval    = 0;
 2d8:	e59f20b4 	ldr	r2, [pc, #180]	; 394 <.text+0x394>
 2dc:	e5043f9f 	str	r3, [r4, #-3999]
  STME0_CNT  = 0;
  STME0_VAL  = 50000000; // threshold value for 1s ticks
 2e0:	e3a017be 	mov	r1, #49807360	; 0x2f80000
 2e4:	e283301d 	add	r3, r3, #29	; 0x1d
 2e8:	e5045f9b 	str	r5, [r4, #-3995]
 2ec:	e2811a2f 	add	r1, r1, #192512	; 0x2f000
 2f0:	e5043f97 	str	r3, [r4, #-3991]
 2f4:	e5825000 	str	r5, [r2]
  STME0_CONF = (1<<2) | (1<<1) | (1<<0); // interrupt en, auto reset, timer enable
  VICVectAddr0 = (unsigned long)timer0_isr;
 2f8:	e59f2098 	ldr	r2, [pc, #152]	; 398 <.text+0x398>
 2fc:	e3e00000 	mvn	r0, #0	; 0x0
 300:	e2811080 	add	r1, r1, #128	; 0x80
 304:	e2433079 	sub	r3, r3, #121	; 0x79
 308:	e5045fdf 	str	r5, [r4, #-4063]
 30c:	e5041fdb 	str	r1, [r4, #-4059]
 310:	e5043fd7 	str	r3, [r4, #-4055]
 314:	e5002fbf 	str	r2, [r0, #-4031]
  VICVectCntl0 = (1<<5) | 0; // enable and channel select = 0 (timer0)
 318:	e2833019 	add	r3, r3, #25	; 0x19
  VICIntEnable = (1<<0); // enable channel 0 (timer0)
 31c:	e3a02001 	mov	r2, #1	; 0x1
 320:	e5003f7f 	str	r3, [r0, #-3967]
 324:	e5002fef 	str	r2, [r0, #-4079]
  
  //i2c0_send_byte(56, 0xCC);

  enable_irq();
 328:	ebffffc5 	bl	244 <enable_irq>
 32c:	e1a06005 	mov	r6, r5
 330:	ea000001 	b	33c <main+0xa8>

  while(1)
  {
    //disable_irq();
    data = uart0_read_byte();
    if(data > -1)
    {
      spi0_send_byte(data, 255);
      uart0_send_byte(data);
    }
    if((PS2_STAT & (1<<1)) != 0) // char available?
    {
	  PS2_STAT = 0; // ack
	  data = PS2_DATA;
      spi0_send_byte(data, 255);
      uart0_send_byte(data);
    }
    //enable_irq();
	led_timer++;
	GPIO0_OUT = led_timer >> 16;
 334:	e1a03846 	mov	r3, r6, asr #16
 338:	e5053fff 	str	r3, [r5, #-4095]
 33c:	ebffff95 	bl	198 <uart0_read_byte>
 340:	e2504000 	subs	r4, r0, #0	; 0x0
 344:	e3e05a0f 	mvn	r5, #61440	; 0xf000
 348:	e2866001 	add	r6, r6, #1	; 0x1
 34c:	e3a010ff 	mov	r1, #255	; 0xff
 350:	ba000002 	blt	360 <main+0xcc>
 354:	ebffff83 	bl	168 <spi0_send_byte>
 358:	e20400ff 	and	r0, r4, #255	; 0xff
 35c:	ebffff93 	bl	1b0 <uart0_send_byte>
 360:	e5153f8b 	ldr	r3, [r5, #-3979]
 364:	e3130002 	tst	r3, #2	; 0x2
 368:	e3a010ff 	mov	r1, #255	; 0xff
 36c:	0afffff0 	beq	334 <main+0xa0>
 370:	e3a03000 	mov	r3, #0	; 0x0
 374:	e5053f8b 	str	r3, [r5, #-3979]
 378:	e5154f8f 	ldr	r4, [r5, #-3983]
 37c:	e1a00004 	mov	r0, r4
 380:	e20440ff 	and	r4, r4, #255	; 0xff
 384:	ebffff77 	bl	168 <spi0_send_byte>
 388:	e1a00004 	mov	r0, r4
 38c:	ebffff87 	bl	1b0 <uart0_send_byte>
 390:	eaffffe7 	b	334 <main+0xa0>
 394:	0000039c 	muleq	r0, ip, r3
 398:	00000130 	andeq	r0, r0, r0, lsr r1
