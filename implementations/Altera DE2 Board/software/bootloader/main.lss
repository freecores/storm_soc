
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000052c  fff00000  fff00000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00002000  00000000  00000000  00000074  2**0
                  ALLOC
  2 .comment      0000001b  00000000  00000000  0000852c  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000040  00000000  00000000  00008548  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000081  00000000  00000000  00008588  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000271  00000000  00000000  00008609  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000011d  00000000  00000000  0000887a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000167  00000000  00000000  00008997  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000b8  00000000  00000000  00008b00  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000010e  00000000  00000000  00008bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000001b7  00000000  00000000  00008cc6  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

fff00000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------------------------------------------------
Vectors:
        b     _start                    // reset - _start
fff00000:	ea000012 	b	fff00050 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
fff00004:	e59ff014 	ldr	pc, [pc, #20]	; fff00020 <_undf>
        ldr   pc,_swi                   // SWI - _swi
fff00008:	e59ff014 	ldr	pc, [pc, #20]	; fff00024 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
fff0000c:	e59ff014 	ldr	pc, [pc, #20]	; fff00028 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
fff00010:	e59ff014 	ldr	pc, [pc, #20]	; fff0002c <_dabt>
        nop                             // reserved
fff00014:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
fff00018:	e51ffff0 	ldr	pc, [pc, #-4080]	; ffeff030 <_stack+0xffefd030>
        ldr   pc,_fiq                   // FIQ - _fiq
fff0001c:	e59ff010 	ldr	pc, [pc, #16]	; fff00034 <_fiq>

fff00020 <_undf>:
fff00020:	fff00038 	undefined instruction 0xfff00038

fff00024 <_swi>:
fff00024:	fff0003c 	undefined instruction 0xfff0003c

fff00028 <_pabt>:
fff00028:	fff00040 	undefined instruction 0xfff00040

fff0002c <_dabt>:
fff0002c:	fff00044 	undefined instruction 0xfff00044

fff00030 <_irq>:
fff00030:	fff00048 	undefined instruction 0xfff00048

fff00034 <_fiq>:
fff00034:	fff0004c 	undefined instruction 0xfff0004c

fff00038 <__undf>:


// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
fff00038:	eafffffe 	b	fff00038 <__undf>

fff0003c <__swi>:
__swi:  b     .                         // SWI
fff0003c:	eafffffe 	b	fff0003c <__swi>

fff00040 <__pabt>:
__pabt: b     .                         // program abort
fff00040:	eafffffe 	b	fff00040 <__pabt>

fff00044 <__dabt>:
__dabt: b     .                         // data abort
fff00044:	eafffffe 	b	fff00044 <__dabt>

fff00048 <__irq>:
__irq:  b     .                         // IRQ
fff00048:	eafffffe 	b	fff00048 <__irq>

fff0004c <__fiq>:
__fiq:  b     .                         // FIQ
fff0004c:	eafffffe 	b	fff0004c <__fiq>

fff00050 <_mainCRTStartup>:

        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// -------------------------------------------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Who am I? Where am I going?

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// ----------------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
fff00050:	e59f00e8 	ldr	r0, [pc, #232]	; fff00140 <.text+0x140>
		mrs   r1,CPSR
fff00054:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
fff00058:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
fff0005c:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
fff00060:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
fff00064:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
fff00068:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
fff0006c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
fff00070:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
fff00074:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
fff00078:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
fff0007c:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
fff00080:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
fff00084:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
fff00088:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
fff0008c:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
fff00090:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
fff00094:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
fff00098:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
fff0009c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
fff000a0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
fff000a4:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
fff000a8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
fff000ac:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
fff000b0:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
fff000b4:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
fff000b8:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
fff000bc:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
fff000c0:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
fff000c4:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
fff000c8:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
fff000cc:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
fff000d0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
fff000d4:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
fff000d8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
fff000dc:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -------------------------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
fff000e0:	e59f105c 	ldr	r1, [pc, #92]	; fff00144 <.text+0x144>
        ldr   r2,=_data                 // -> data start
fff000e4:	e59f205c 	ldr	r2, [pc, #92]	; fff00148 <.text+0x148>
        ldr   r3,=_edata                // -> end of data
fff000e8:	e59f305c 	ldr	r3, [pc, #92]	; fff0014c <.text+0x14c>

fff000ec <x01>:
x01:    cmp   r2,r3                     // check if data to move
fff000ec:	e1520003 	cmp	r2, r3
		beq   y01
fff000f0:	0a000002 	beq	fff00100 <y01>
        ldrlo r0,[r1],#4                // copy it
fff000f4:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
fff000f8:	34820004 	strcc	r0, [r2], #4
        blo   x01                       // loop until done
fff000fc:	3afffffa 	bcc	fff000ec <x01>

fff00100 <y01>:
y01:
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
fff00100:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
fff00104:	e59f1044 	ldr	r1, [pc, #68]	; fff00150 <.text+0x150>
        ldr   r2,=__bss_end__           // -> bss end
fff00108:	e59f2044 	ldr	r2, [pc, #68]	; fff00154 <.text+0x154>

fff0010c <x02>:
x02:    cmp   r1,r2                     // check if data to clear
fff0010c:	e1510002 	cmp	r1, r2
		beq   y02
fff00110:	0a000001 	beq	fff0011c <y02>
        strlo r0,[r1],#4                // clear 4 bytes
fff00114:	34810004 	strcc	r0, [r1], #4
        blo   x02                       // loop until done
fff00118:	3afffffb 	bcc	fff0010c <x02>

fff0011c <y02>:
y02:
// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
fff0011c:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
fff00120:	e1a01000 	mov	r1, r0
        mov   r2,r0
fff00124:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
fff00128:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
fff0012c:	e1a07000 	mov	r7, r0
        ldr   r10,=main
fff00130:	e59fa020 	ldr	sl, [pc, #32]	; fff00158 <.text+0x158>
        mov   lr,pc
fff00134:	e1a0e00f 	mov	lr, pc
        mov   pc, r10                   // enter main()
fff00138:	e1a0f00a 	mov	pc, sl

fff0013c <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
fff0013c:	eafffffe 	b	fff0013c <_reset>
fff00140:	00002000 	andeq	r2, r0, r0
fff00144:	fff0052c 	undefined instruction 0xfff0052c
fff00148:	00000000 	andeq	r0, r0, r0
fff0014c:	fff0052c 	undefined instruction 0xfff0052c
fff00150:	00000000 	andeq	r0, r0, r0
fff00154:	fff0052c 	undefined instruction 0xfff0052c
fff00158:	fff002e4 	undefined instruction 0xfff002e4

fff0015c <uart0_read_byte>:

/* ---- UART0 read byte ---- */
int uart0_read_byte(void)
{
  if ((UART0_SREG & 2) != 0) // byte available?
fff0015c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
fff00160:	e5123fe3 	ldr	r3, [r2, #-4067]
fff00164:	e3130002 	tst	r3, #2	; 0x2
fff00168:	e3e00000 	mvn	r0, #0	; 0x0
    return UART0_DATA;
fff0016c:	15120fe7 	ldrne	r0, [r2, #-4071]
  else
    return -1;
}
fff00170:	e1a0f00e 	mov	pc, lr

fff00174 <uart0_send_byte>:


/* ---- UART0 write byte ---- */
int uart0_send_byte(char ch)
{
fff00174:	e20000ff 	and	r0, r0, #255	; 0xff
fff00178:	e3e02a0f 	mvn	r2, #61440	; 0xf000
  while((UART0_SREG & 1) == 0); // uart busy?
fff0017c:	e5123fe3 	ldr	r3, [r2, #-4067]
fff00180:	e3130001 	tst	r3, #1	; 0x1
fff00184:	0afffffc 	beq	fff0017c <uart0_send_byte+0x8>
  ch = ch & 255;
  UART0_DATA = ch;
fff00188:	e5020fe7 	str	r0, [r2, #-4071]
  return (int)ch;
}
fff0018c:	e1a0f00e 	mov	pc, lr

fff00190 <uart0_printf>:


/* ---- UART0 send string ---- */
const char *uart0_printf(const char *string)
{
fff00190:	e92d4010 	stmdb	sp!, {r4, lr}
fff00194:	e1a04000 	mov	r4, r0
  char ch;
  while ((ch = *string)) {
fff00198:	e5d00000 	ldrb	r0, [r0]
fff0019c:	e3500000 	cmp	r0, #0	; 0x0
fff001a0:	1a000003 	bne	fff001b4 <uart0_printf+0x24>
fff001a4:	ea000005 	b	fff001c0 <uart0_printf+0x30>
fff001a8:	e5f40001 	ldrb	r0, [r4, #1]!
fff001ac:	e3500000 	cmp	r0, #0	; 0x0
fff001b0:	0a000002 	beq	fff001c0 <uart0_printf+0x30>
    if (uart0_send_byte(ch)<0) break;
fff001b4:	ebffffee 	bl	fff00174 <uart0_send_byte>
fff001b8:	e3500000 	cmp	r0, #0	; 0x0
fff001bc:	aafffff9 	bge	fff001a8 <uart0_printf+0x18>
    string++;
  }
  return string;
}
fff001c0:	e1a00004 	mov	r0, r4
fff001c4:	e8bd8010 	ldmia	sp!, {r4, pc}

fff001c8 <mem_dump>:


/* ---- Memory Dump ---- */
void mem_dump(void)
{
fff001c8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
fff001cc:	e3a05000 	mov	r5, #0	; 0x0
  unsigned long word_buffer;
  unsigned long *data_pointer = 0;

  while(data_pointer != RAM_SIZE)
  {
    word_buffer = *data_pointer;
fff001d0:	e4954004 	ldr	r4, [r5], #4
    uart0_send_byte(word_buffer >> 24);
fff001d4:	e1a00c24 	mov	r0, r4, lsr #24
fff001d8:	ebffffe5 	bl	fff00174 <uart0_send_byte>
    uart0_send_byte(word_buffer >> 16);
fff001dc:	e1a00824 	mov	r0, r4, lsr #16
fff001e0:	e20000ff 	and	r0, r0, #255	; 0xff
fff001e4:	ebffffe2 	bl	fff00174 <uart0_send_byte>
    uart0_send_byte(word_buffer >>  8);
fff001e8:	e1a00424 	mov	r0, r4, lsr #8
fff001ec:	e20000ff 	and	r0, r0, #255	; 0xff
    uart0_send_byte(word_buffer >>  0);
fff001f0:	e20440ff 	and	r4, r4, #255	; 0xff
fff001f4:	ebffffde 	bl	fff00174 <uart0_send_byte>
fff001f8:	e1a00004 	mov	r0, r4
fff001fc:	ebffffdc 	bl	fff00174 <uart0_send_byte>
fff00200:	e3a03502 	mov	r3, #8388608	; 0x800000
fff00204:	e2833a02 	add	r3, r3, #8192	; 0x2000
fff00208:	e1550003 	cmp	r5, r3
fff0020c:	1affffef 	bne	fff001d0 <mem_dump+0x8>
	data_pointer++;
  }
  while(1)
    asm volatile ("NOP");
fff00210:	e1a00000 	nop			(mov r0,r0)
fff00214:	e1a00000 	nop			(mov r0,r0)
fff00218:	eafffffc 	b	fff00210 <mem_dump+0x48>

fff0021c <jump_app>:
}


/* ---- Jump to application ---- */
void jump_app(void)
{
  unsigned long _cp_val;

  SSEG0_CTRL = 0; // deactivate status display
fff0021c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
fff00220:	e3a03000 	mov	r3, #0	; 0x0
fff00224:	e5023ff3 	str	r3, [r2, #-4083]
fff00228:	e52de004 	str	lr, [sp, #-4]!
  SSEG1_CTRL = 0; // deactivate counter display
fff0022c:	e5023feb 	str	r3, [r2, #-4075]

  uart0_printf("\r\nStarting application...\r\n");
fff00230:	e59f001c 	ldr	r0, [pc, #28]	; fff00254 <.text+0x254>
fff00234:	ebffffd5 	bl	fff00190 <uart0_printf>

  asm volatile ("mrc  p15, 0, %0, c6, c6" : "=r" (_cp_val) : /* no inputs */  );
fff00238:	ee163f16 	mrc	15, 0, r3, cr6, cr6, {0}
  _cp_val = _cp_val & ~(1<<3); // disable write-through strategy
  asm volatile ("mcr  p15, 0, %0, c6, c6, 0" : /* no outputs */ : "r" (_cp_val));
fff0023c:	e3c33008 	bic	r3, r3, #8	; 0x8
fff00240:	ee063f16 	mcr	15, 0, r3, cr6, cr6, {0}
 
  asm volatile ("mov PC, #0"); // jump to application
fff00244:	e3a0f000 	mov	pc, #0	; 0x0
  while(1)
    asm volatile ("NOP");
fff00248:	e1a00000 	nop			(mov r0,r0)
fff0024c:	e1a00000 	nop			(mov r0,r0)
fff00250:	eafffffc 	b	fff00248 <jump_app+0x2c>
fff00254:	fff0042c 	undefined instruction 0xfff0042c

fff00258 <program_loader>:
}


/* ---- Download Program ---- */
void program_loader(void)
{
fff00258:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
  int timer, data, shift;
  unsigned long _cp_val;
  unsigned long word_buffer;
  unsigned long *data_pointer;

  uart0_printf("\r\nWaiting for data\r\n");
fff0025c:	e59f0078 	ldr	r0, [pc, #120]	; fff002dc <.text+0x2dc>
fff00260:	ebffffca 	bl	fff00190 <uart0_printf>

  SSEG0_CTRL = 118963166; // show 'LoAd' screen
fff00264:	e59f2074 	ldr	r2, [pc, #116]	; fff002e0 <.text+0x2e0>
  SSEG1_CTRL = 0; // deactivate counter display
fff00268:	e3a01000 	mov	r1, #0	; 0x0
fff0026c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
fff00270:	e3a04626 	mov	r4, #39845888	; 0x2600000
fff00274:	e5032ff3 	str	r2, [r3, #-4083]
fff00278:	e2844b96 	add	r4, r4, #153600	; 0x25800
fff0027c:	e5031feb 	str	r1, [r3, #-4075]
fff00280:	e1a06001 	mov	r6, r1
fff00284:	e2844c02 	add	r4, r4, #512	; 0x200
fff00288:	e3a05020 	mov	r5, #32	; 0x20
fff0028c:	e1a07001 	mov	r7, r1

  data_pointer = 0; // beginning of RAM
  shift = 32;
  word_buffer = 0;
  timer = timeout;
  while(timer != 0) // timer loop
  {
    data = uart0_read_byte();
fff00290:	ebffffb1 	bl	fff0015c <uart0_read_byte>
    if(data == -1)
fff00294:	e3700001 	cmn	r0, #1	; 0x1
fff00298:	0a00000b 	beq	fff002cc <program_loader+0x74>
	  timer--;
	else // byte received
    {
      // reset timer
	  timer = timeout;
	  // construct 32-bit memory entry
      shift = shift - 8;
fff0029c:	e2455008 	sub	r5, r5, #8	; 0x8
	  word_buffer = word_buffer | (data << shift);
fff002a0:	e1866510 	orr	r6, r6, r0, lsl r5
	  if(shift == 0) // word completed
fff002a4:	e3550000 	cmp	r5, #0	; 0x0
	  {
	    // store memory entry
		*data_pointer = word_buffer;
fff002a8:	04876004 	streq	r6, [r7], #4
		data_pointer = data_pointer + 1;
fff002ac:	02855020 	addeq	r5, r5, #32	; 0x20
fff002b0:	03a06000 	moveq	r6, #0	; 0x0
fff002b4:	ebffffa8 	bl	fff0015c <uart0_read_byte>
		word_buffer = 0;
		shift = 32;
	  }
	}
  }
  jump_app();
fff002b8:	e3a04626 	mov	r4, #39845888	; 0x2600000
fff002bc:	e2844b96 	add	r4, r4, #153600	; 0x25800
fff002c0:	e3700001 	cmn	r0, #1	; 0x1
fff002c4:	e2844c02 	add	r4, r4, #512	; 0x200
fff002c8:	1afffff3 	bne	fff0029c <program_loader+0x44>
fff002cc:	e2544001 	subs	r4, r4, #1	; 0x1
fff002d0:	1affffee 	bne	fff00290 <program_loader+0x38>
}
fff002d4:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
fff002d8:	eaffffcf 	b	fff0021c <jump_app>
fff002dc:	fff00448 	undefined instruction 0xfff00448
fff002e0:	07173bde 	undefined

fff002e4 <main>:


/* ---- Main function ---- */
int main(void)
{
  int timer, data;
  unsigned long _cp_val;
  unsigned long *data_pointer;

  SSEG0_CTRL = 261566072; // show 'boot' screen
fff002e4:	e59f3120 	ldr	r3, [pc, #288]	; fff0040c <.text+0x40c>
fff002e8:	e3e01a0f 	mvn	r1, #61440	; 0xf000
  SSEG1_CTRL = 0; // clear counter display
fff002ec:	e3a02000 	mov	r2, #0	; 0x0
fff002f0:	e5013ff3 	str	r3, [r1, #-4083]
fff002f4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
fff002f8:	e5012feb 	str	r2, [r1, #-4075]

  // enable write-through -> flush-cache required
  asm volatile (" mrc  p15, 0, %0, c6, c6" : "=r" (_cp_val) : /* no inputs */  );
fff002fc:	ee163f16 	mrc	15, 0, r3, cr6, cr6, {0}
//_cp_val = _cp_val | (1<<0) | (1<<3);
  _cp_val = _cp_val | (1<<3);
  asm volatile (" mcr  p15, 0, %0, c6, c6, 0" : /* no outputs */ : "r" (_cp_val));
fff00300:	e3833008 	orr	r3, r3, #8	; 0x8
fff00304:	ee063f16 	mcr	15, 0, r3, cr6, cr6, {0}

  // configure external memory controller
  XMC_CSR = 0x0B000600; // refresh prescaler || refresh interval
  XMC_BA_MASK = 255;
  // Trfc, Trp, Trcd, Twr, Burst length = pog, opmode, cas lat = 2, burst type = seq, burst length = 8
  XMC_TMS0 = 0x04138023; // = (4<<24) || (1<<20) || (1<<17) || (4<<15) || (0<<9) || (0<<7) || (2<<4) || (0<<3) || (3<<0);
fff00308:	e3a0c641 	mov	ip, #68157440	; 0x4100000
fff0030c:	e28cc90e 	add	ip, ip, #229376	; 0x38000
fff00310:	e3a0140b 	mov	r1, #184549376	; 0xb000000
  // Base addr, no parity, row open, bank-col addr , wp = 0, size = ?, b_width = 16, type = sdram, en
  XMC_CSC0 = 0x00000411; // = (0<<16) || (0<<11) || (1<<10) || (0<<9) || (0<<8) || (0<<6) || (1<<4) || (0<<1) || (1<<0);
fff00314:	e3a04e41 	mov	r4, #1040	; 0x410
fff00318:	e3e02a01 	mvn	r2, #4096	; 0x1000
fff0031c:	e2811c06 	add	r1, r1, #1536	; 0x600
fff00320:	e28cc023 	add	ip, ip, #35	; 0x23
fff00324:	e3a030ff 	mov	r3, #255	; 0xff
fff00328:	e2844001 	add	r4, r4, #1	; 0x1
fff0032c:	e50210ff 	str	r1, [r2, #-255]

  uart0_printf("\r\nSTORM Core Processor System - by Stephan Nolting\r\n");
fff00330:	e59f00d8 	ldr	r0, [pc, #216]	; fff00410 <.text+0x410>
fff00334:	e50230f7 	str	r3, [r2, #-247]
fff00338:	e502c0eb 	str	ip, [r2, #-235]
fff0033c:	e50240ef 	str	r4, [r2, #-239]
fff00340:	ebffff92 	bl	fff00190 <uart0_printf>
  uart0_printf("Bootloader for STORM SoC on Altera DE2-Board\r\n");
fff00344:	e59f00c8 	ldr	r0, [pc, #200]	; fff00414 <.text+0x414>
fff00348:	ebffff90 	bl	fff00190 <uart0_printf>
  uart0_printf("Version: 19.03.2012\r\n");
fff0034c:	e59f00c4 	ldr	r0, [pc, #196]	; fff00418 <.text+0x418>
fff00350:	ebffff8e 	bl	fff00190 <uart0_printf>

  uart0_printf("\r\n0: RAM dump\r\n");
fff00354:	e59f00c0 	ldr	r0, [pc, #192]	; fff0041c <.text+0x41c>
fff00358:	ebffff8c 	bl	fff00190 <uart0_printf>
  uart0_printf("1: Load via UART\r\n");
fff0035c:	e59f00bc 	ldr	r0, [pc, #188]	; fff00420 <.text+0x420>
fff00360:	ebffff8a 	bl	fff00190 <uart0_printf>
  uart0_printf("x: Jump to application\r\n");
fff00364:	e59f00b8 	ldr	r0, [pc, #184]	; fff00424 <.text+0x424>
fff00368:	ebffff88 	bl	fff00190 <uart0_printf>
  uart0_printf("\r\nSelect: ");
fff0036c:	e59f00b4 	ldr	r0, [pc, #180]	; fff00428 <.text+0x428>
fff00370:	ebffff86 	bl	fff00190 <uart0_printf>
fff00374:	e3a04626 	mov	r4, #39845888	; 0x2600000
fff00378:	e2844b96 	add	r4, r4, #153600	; 0x25800
fff0037c:	e2844c02 	add	r4, r4, #512	; 0x200
fff00380:	e3e05a0f 	mvn	r5, #61440	; 0xf000
fff00384:	ea00000b 	b	fff003b8 <main+0xd4>

  timer = timeout;
  while(timer != 0)
  {
	data = uart0_read_byte();
    if(data == '1')      // start program downloader
	{
	  uart0_send_byte((char)data);
	  program_loader();
	}
	else if((data == 'x') || ((GPIO0_IN & (1<<16)) == 0)) // start application
fff00388:	e3500078 	cmp	r0, #120	; 0x78
fff0038c:	0a000019 	beq	fff003f8 <main+0x114>
fff00390:	e5153ffb 	ldr	r3, [r5, #-4091]
fff00394:	e3130801 	tst	r3, #65536	; 0x10000
fff00398:	0a000016 	beq	fff003f8 <main+0x114>
	{
	  uart0_send_byte((char)data);
	  break;
	}
	else if(data == '0') // print memory content
fff0039c:	e3500030 	cmp	r0, #48	; 0x30
	{
	  uart0_send_byte((char)data);
	  mem_dump();
	}
	else
	  timer--;
fff003a0:	12444001 	subne	r4, r4, #1	; 0x1
fff003a4:	0a000010 	beq	fff003ec <main+0x108>
	SSEG1_DATA = timer >> 18;
fff003a8:	e1a03944 	mov	r3, r4, asr #18
fff003ac:	e3540000 	cmp	r4, #0	; 0x0
fff003b0:	e5053fef 	str	r3, [r5, #-4079]
fff003b4:	0a000009 	beq	fff003e0 <main+0xfc>
fff003b8:	ebffff67 	bl	fff0015c <uart0_read_byte>
fff003bc:	e3500031 	cmp	r0, #49	; 0x31
fff003c0:	e1a02000 	mov	r2, r0
fff003c4:	1affffef 	bne	fff00388 <main+0xa4>
fff003c8:	ebffff69 	bl	fff00174 <uart0_send_byte>
fff003cc:	ebffffa1 	bl	fff00258 <program_loader>
fff003d0:	e1a03944 	mov	r3, r4, asr #18
fff003d4:	e3540000 	cmp	r4, #0	; 0x0
fff003d8:	e5053fef 	str	r3, [r5, #-4079]
fff003dc:	1afffff5 	bne	fff003b8 <main+0xd4>
  }
  jump_app();
fff003e0:	ebffff8d 	bl	fff0021c <jump_app>
}
fff003e4:	e3a00000 	mov	r0, #0	; 0x0
fff003e8:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
fff003ec:	ebffff60 	bl	fff00174 <uart0_send_byte>
fff003f0:	ebffff74 	bl	fff001c8 <mem_dump>
fff003f4:	eaffffeb 	b	fff003a8 <main+0xc4>
fff003f8:	e20200ff 	and	r0, r2, #255	; 0xff
fff003fc:	ebffff5c 	bl	fff00174 <uart0_send_byte>
fff00400:	ebffff85 	bl	fff0021c <jump_app>
fff00404:	e3a00000 	mov	r0, #0	; 0x0
fff00408:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
fff0040c:	0f972e78 	svceq	0x00972e78
fff00410:	fff00460 	undefined instruction 0xfff00460
fff00414:	fff00498 	undefined instruction 0xfff00498
fff00418:	fff004c8 	undefined instruction 0xfff004c8
fff0041c:	fff004e0 	undefined instruction 0xfff004e0
fff00420:	fff004f0 	undefined instruction 0xfff004f0
fff00424:	fff00504 	undefined instruction 0xfff00504
fff00428:	fff00520 	undefined instruction 0xfff00520
fff0042c:	0d0a5374 	stceq	3, cr5, [sl, #-464]
fff00430:	61727469 	cmnvs	r2, r9, ror #8
fff00434:	6e672061 	cdpvs	0, 6, cr2, cr7, cr1, {3}
fff00438:	70706c69 	rsbvcs	r6, r0, r9, ror #24
fff0043c:	63617469 	cmnvs	r1, #1761607680	; 0x69000000
fff00440:	6f6e2e2e 	svcvs	0x006e2e2e
fff00444:	2e0d0a00 	fmacscs	s0, s26, s0
fff00448:	0d0a5761 	stceq	7, cr5, [sl, #-388]
fff0044c:	6974696e 	ldmvsdb	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
fff00450:	6720666f 	strvs	r6, [r0, -pc, ror #12]!
fff00454:	72206461 	eorvc	r6, r0, #1627389952	; 0x61000000
fff00458:	74610d0a 	strvcbt	r0, [r1], #-3338
fff0045c:	00000000 	andeq	r0, r0, r0
fff00460:	0d0a5354 	stceq	3, cr5, [sl, #-336]
fff00464:	4f524d20 	svcmi	0x00524d20
fff00468:	436f7265 	cmnmi	pc, #1342177286	; 0x50000006
fff0046c:	2050726f 	subcss	r7, r0, pc, ror #4
fff00470:	63657373 	cmnvs	r5, #-872415231	; 0xcc000001
fff00474:	6f722053 	svcvs	0x00722053
fff00478:	79737465 	ldmvcdb	r3!, {r0, r2, r5, r6, sl, ip, sp, lr}^
fff0047c:	6d202d20 	stcvs	13, cr2, [r0, #-128]!
fff00480:	62792053 	rsbvss	r2, r9, #83	; 0x53
fff00484:	74657068 	strvcbt	r7, [r5], #-104
fff00488:	616e204e 	cmnvs	lr, lr, asr #32
fff0048c:	6f6c7469 	svcvs	0x006c7469
fff00490:	6e670d0a 	cdpvs	13, 6, cr0, cr7, cr10, {0}
fff00494:	00000000 	andeq	r0, r0, r0
fff00498:	426f6f74 	rsbmi	r6, pc, #464	; 0x1d0
fff0049c:	6c6f6164 	stfvse	f6, [pc], #-400
fff004a0:	65722066 	ldrvsb	r2, [r2, #-102]!
fff004a4:	6f722053 	svcvs	0x00722053
fff004a8:	544f524d 	strplb	r5, [pc], #589	; fff004b0 <.text+0x4b0>
fff004ac:	20536f43 	subcss	r6, r3, r3, asr #30
fff004b0:	206f6e20 	rsbcs	r6, pc, r0, lsr #28
fff004b4:	416c7465 	cmnmi	ip, r5, ror #8
fff004b8:	72612044 	rsbvc	r2, r1, #68	; 0x44
fff004bc:	45322d42 	ldrmi	r2, [r2, #-3394]!
fff004c0:	6f617264 	svcvs	0x00617264
fff004c4:	0d0a0000 	stceq	0, cr0, [sl]
fff004c8:	56657273 	undefined
fff004cc:	696f6e3a 	stmvsdb	pc!, {r1, r3, r4, r5, r9, sl, fp, sp, lr}^
fff004d0:	2031392e 	eorcss	r3, r1, lr, lsr #18
fff004d4:	30332e32 	eorccs	r2, r3, r2, lsr lr
fff004d8:	3031320d 	eorccs	r3, r1, sp, lsl #4
fff004dc:	0a000000 	beq	fff004e4 <.text+0x4e4>
fff004e0:	0d0a303a 	stceq	0, cr3, [sl, #-232]
fff004e4:	2052414d 	subcss	r4, r2, sp, asr #2
fff004e8:	2064756d 	rsbcs	r7, r4, sp, ror #10
fff004ec:	700d0a00 	andvc	r0, sp, r0, lsl #20
fff004f0:	313a204c 	teqcc	sl, ip, asr #32
fff004f4:	6f616420 	svcvs	0x00616420
fff004f8:	76696120 	strvcbt	r6, [r9], -r0, lsr #2
fff004fc:	55415254 	strplb	r5, [r1, #-596]
fff00500:	0d0a0000 	stceq	0, cr0, [sl]
fff00504:	783a204a 	ldmvcda	sl!, {r1, r3, r6, sp}
fff00508:	756d7020 	strvcb	r7, [sp, #-32]!
fff0050c:	746f2061 	strvcbt	r2, [pc], #97	; fff00514 <.text+0x514>
fff00510:	70706c69 	rsbvcs	r6, r0, r9, ror #24
fff00514:	63617469 	cmnvs	r1, #1761607680	; 0x69000000
fff00518:	6f6e0d0a 	svcvs	0x006e0d0a
fff0051c:	00000000 	andeq	r0, r0, r0
fff00520:	0d0a5365 	stceq	3, cr5, [sl, #-404]
fff00524:	6c656374 	stcvsl	3, cr6, [r5], #-464
fff00528:	3a200000 	bcc	700530 <_stack+0x6fe530>
